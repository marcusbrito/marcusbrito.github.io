= Processamento Digital de Imagem
Marcus Brito <mvobrito@gmail.com>
:toc: left
:numbered:
:source-highlighter: pygments

== Sobre

Esse espaço tem como objetivo expor os projetos e exercícios da matéria de Processamento Digital de Imagem

== Primeira Unidade
=== Negativo
==== Objetivo

A ideia do programa é receber do usuário as coordenadas de dois pontos e, em seguida, exibir a imagem(que foi inicializada junto com o programa), invertendo a cor dos pixels da região limitada pelos pontos.

==== Código

[source,cpp]
.regions.cpp
----
include::regions.cpp[]
----

==== Análise

* O programa inicia lendo a imagem:

.dead.png
image::dead.png[]

* Em seguida, recebe os pontos do usuário, e verifica se eles estão dentro dos limites da imagem:

[source,cpp]
----
if(p1[0]<0 || p1[1]<0 || p2[0]<0 || p2[1]<0 || p1[0]> image.size().height || p1[1]> image.size().width || p2[0]> image.size().height || p2[1]> image.size().width){
      flag = 1;
      cout << "Coodenadas invalidas. Digite novamente:" << endl;
    }
----

* Então, um loop(for) percorre a região limitada pelos pontos invertendo o valor dos pixels a partir da operação "Cor negativa = 255 - Cor original":

[source,cpp]
----
for(int i= p1[0];i<=p2[0];i++){
    for(int j=p1[1];j<=p2[1];j++){
      image.at<uchar>(i,j) = 255 - image.at<uchar>(i,j);
    }
  }
----

* Por fim, exibe a imagem com o efeito aplicado:

.invertida.png
image::invertida.png[]

=== Troca de Regões
==== Objetivo

O objetivo do programa é trocar as posições dos "quadrantes" da imagem.

==== Código

[source,cpp]
.trocaregioes.cpp
----
include::trocaregioes.cpp[]
----

==== Análise

* Nesse caso, a imagem já é passado como parâmetro ao executarmos o programa no terminal:

.dead.png
image::dead.png[]

* Em seguida, uma segunda imagem "trocada" é criada, com o mesmo tamanho da imagem original:

[source,cpp]
----
Mat trocada(height, width, image.type());
----

* Então, "trocada" é preenchida com os quadrantes da imagem original, só que com suas posições invertidas. Esse processo é feito utilizando dois métodos da biblioteca OpenCV:
+
	Rect - Cria uma seleção retângular a partir das coordenadas e dimenssões passadas como parâmetro.
+
	copyTo - Copia o conteudo da primeira imagem par a segunda(Imagem1.copyTo(Imagem2)).

[source,cpp]
----
  image(Rect(0, 0, width/2, height/2)).copyTo(trocada(Rect(width/2, height/2, width/2, height/2)));
  
  image(Rect(0, height/2, width/2, height/2)).copyTo(trocada(Rect(width/2,0, width/2, height/2)));

  image(Rect(width/2,0,width/2,height/2)).copyTo(trocada(Rect(0,height/2, width/2, height/2)));

  image(Rect(width/2,height/2,width/2,height/2)).copyTo(trocada(Rect(0,0, width/2, height/2)));
----

* Por fim, exibe a imagem com o efeito aplicado:

.trocada.png
image::trocada.png[]

=== Contador de Bolhas
==== Objetivo

O objetivo do código é efetuar a contagem de bolhas presentes na imagem, identificando se elas possuem ou não buracos.

==== Código

[source,cpp]
.labeling.cpp
----
include::labeling.cpp[]
----

==== Análise
* Inicialmente, o programa abre a imagem:

.bolhas.png
image::bolhas.png[]

* Em seguida, para retirar as bolhas que tocam as bordas(já que não é possível saber se elas possuem bolhas ou não), um loop percorre as bordas e, caso encontre alguma pixel com valor 255(branco), ele executa a função seedfill, que preenche a bolha com a cor preta:

[source,cpp]
----
for(int i=0; i<height; i++)
{
    if(image.at<uchar>(i,0) == 255)
    {
      p.x=0;
      p.y=i;
      seedfill(image,p,0);
    }
    if(image.at<uchar>(i,width-1) == 255)
    {
      p.x=width-1;
      p.y=i;
      seedfill(image,p,0);
    }
  }
  for(int j=0; j<width; j++) 
  {
    if(image.at<uchar>(0,j) == 255)
    {
      p.x=j;
      p.y=0;
      seedfill(image,p,0);
    }
    if(image.at<uchar>(height -1,j) == 255)
    {
      p.x=j;
      p.y=height-1;
      seedfill(image,p,0);
    }
}
----

* A função seedfild, por sua vez, recebe três parâmetros: um tipo Mat(a imagem), um tipo CvPoint(o ponto inicial) e um tipo unsigned char(a cor com qual deseja-se preencher a região). Seu funcionamento ocorre a partir de um tipo Pilha(stack):
+
- Inicia-se a pilha com a posição passada como parâmetro;
+
- Enquanto a pilha não estiver vazia, executa-se o processo:
+
	- Retira-se o elemento da pilha(o do "topo", como é característico da pilha);
	+
	- Verifica se os pontos vizinhos a ele(4-vizinhos) são da mesma cor dele e, caso sejam, são colocados na pilha.
	+
	- "Pinta" o ponto atual com a cor passada por parâmetro;
	+
[source,cpp]
----
void seedfill(Mat image, CvPoint p, unsigned char cor){
  stack<CvPoint> pilha;
  unsigned char cor_atual;
  CvPoint aux1,aux2,aux3,aux4,atual;

  pilha.push(p);
  cor_atual = image.at<uchar>(p.y,p.x);
  while(!pilha.empty()){
    atual = pilha.top();
    pilha.pop();
    
    if(image.at<uchar>(atual.y + 1,atual.x) == cor_atual && atual.y < image.cols - 1 ){

    aux1.x = atual.x;
    aux1.y = atual.y + 1;
    pilha.push(aux1);
    
    }
    if(image.at<uchar>(atual.y - 1,atual.x) == cor_atual && atual.y > 0){

    aux2.x = atual.x;
    aux2.y = atual.y - 1;
    pilha.push(aux2);

    
    }
    if(image.at<uchar>(atual.y,atual.x + 1) == cor_atual && atual.x < image.rows - 1 ){

    aux3.x = atual.x + 1;
    aux3.y = atual.y;
    pilha.push(aux3);

    
    }
    if(image.at<uchar>(atual.y,atual.x - 1) == cor_atual && atual.x > 0){

    aux4.x = atual.x - 1;
    aux4.y = atual.y;
    pilha.push(aux4);
    }
  image.at<uchar>(atual.y,atual.x) = cor;  
  }
}
----

